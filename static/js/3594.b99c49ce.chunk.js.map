{"version":3,"file":"static/js/3594.b99c49ce.chunk.js","mappings":"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","sources":["../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/remark-math/lib/index.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/@milkdown/crepe/src/feature/latex/remark.ts","../node_modules/@milkdown/crepe/src/feature/latex/inline-tooltip/component.ts","../node_modules/@milkdown/crepe/src/feature/latex/inline-tooltip/tooltip.ts","../node_modules/@milkdown/crepe/src/feature/latex/inline-tooltip/view.ts","../node_modules/@milkdown/crepe/src/feature/latex/input-rule.ts","../node_modules/@milkdown/crepe/src/feature/latex/block-latex.ts","../node_modules/@milkdown/crepe/src/feature/latex/index.ts"],"sourcesContent":["/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, \"whitespace\")(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, \"whitespace\")(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n    let size;\n    /** @type {Token} */\n    let token;\n    return start;\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return sequenceOpen(code);\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit('mathTextSequence');\n      return between(code);\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return sequenceClose(code);\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(\"lineEnding\");\n        effects.consume(code);\n        effects.exit(\"lineEnding\");\n        return between;\n      }\n\n      // Data.\n      effects.enter('mathTextData');\n      return data(code);\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (code === null || code === 32 || code === 36 || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = 'mathTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { mathFlow } from './math-flow.js';\nimport { mathText } from './math-text.js';\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  };\n}","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","import remarkMath from 'remark-math'\nimport { $remark } from '@milkdown/kit/utils'\nimport type { Node } from '@milkdown/kit/transformer'\nimport { visit } from 'unist-util-visit'\n\nexport const remarkMathPlugin = $remark<'remarkMath', undefined>(\n  'remarkMath',\n  () => remarkMath\n)\n\nfunction visitMathBlock(ast: Node) {\n  return visit(\n    ast,\n    'math',\n    (\n      node: Node & { value: string },\n      index: number,\n      parent: Node & { children: Node[] }\n    ) => {\n      const { value } = node as Node & { value: string }\n      const newNode = {\n        type: 'code',\n        lang: 'LaTeX',\n        value,\n      }\n      parent.children.splice(index, 1, newNode)\n    }\n  )\n}\n\n/// Turn math block into code block with language LaTeX.\nexport const remarkMathBlockPlugin = $remark(\n  'remarkMathBlock',\n  () => () => visitMathBlock\n)\n","import { c, h, html, type Component } from 'atomico'\nimport type { LatexConfig } from '..'\nimport type { EditorView } from '@milkdown/kit/prose/view'\n\ntype LatexEditComponentProps = {\n  config: Partial<LatexConfig>\n  innerView: EditorView\n  updateValue: () => void\n}\n\nexport const latexEditComponent: Component<LatexEditComponentProps> = ({\n  config,\n  innerView,\n  updateValue,\n}) => {\n  const onMouseDown = (e: MouseEvent) => {\n    e.preventDefault()\n    updateValue?.()\n  }\n  return html`\n    <host>\n      <div class=\"container\">\n        ${innerView && h(innerView.dom, {})}\n        <button onmousedown=${onMouseDown}>\n          ${config?.inlineEditConfirm?.()}\n        </button>\n      </div>\n    </host>\n  `\n}\n\nlatexEditComponent.props = {\n  config: Object,\n  innerView: Object,\n  updateValue: Function,\n}\n\nexport const LatexInlineEditElement = c(latexEditComponent)\n","import { tooltipFactory } from '@milkdown/kit/plugin/tooltip'\n\nexport const inlineLatexTooltip = tooltipFactory('INLINE_LATEX')\n","import type { Ctx } from '@milkdown/kit/ctx'\nimport { TooltipProvider } from '@milkdown/kit/plugin/tooltip'\nimport type { PluginView } from '@milkdown/kit/prose/state'\nimport { EditorState, NodeSelection } from '@milkdown/kit/prose/state'\nimport { EditorView } from '@milkdown/kit/prose/view'\nimport { mathInlineId } from '../inline-latex'\nimport { LatexInlineEditElement } from './component'\nimport type { LatexConfig } from '..'\nimport { keymap } from '@milkdown/kit/prose/keymap'\nimport { redo, undo } from '@milkdown/kit/prose/history'\nimport { Schema } from '@milkdown/kit/prose/model'\n\nexport class LatexInlineTooltip implements PluginView {\n  #content = new LatexInlineEditElement()\n  #provider: TooltipProvider\n  #dom: HTMLElement\n  #innerView: EditorView | null\n\n  constructor(\n    readonly ctx: Ctx,\n    view: EditorView,\n    config: Partial<LatexConfig>\n  ) {\n    this.#provider = new TooltipProvider({\n      debounce: 0,\n      content: this.#content,\n      shouldShow: this.#shouldShow,\n      offset: 10,\n      floatingUIOptions: {\n        placement: 'bottom',\n      },\n    })\n    this.#content.config = config\n    this.#provider.update(view)\n    this.#dom = document.createElement('div')\n    this.#innerView = null\n  }\n\n  #onHide = () => {\n    if (this.#innerView) {\n      this.#innerView.destroy()\n      this.#innerView = null\n    }\n  }\n\n  #shouldShow = (view: EditorView) => {\n    const shouldShow = () => {\n      const { selection, schema } = view.state\n      if (selection.empty) return false\n      if (!(selection instanceof NodeSelection)) return false\n      const node = selection.node\n      if (node.type.name !== mathInlineId) return false\n\n      const textFrom = selection.from\n\n      const paragraph = schema.nodes.paragraph!.create(\n        null,\n        schema.text(node.attrs.value)\n      )\n\n      const innerView = new EditorView(this.#dom, {\n        state: EditorState.create({\n          doc: paragraph,\n          schema: new Schema({\n            nodes: {\n              doc: {\n                content: 'block+',\n              },\n              paragraph: {\n                content: 'inline*',\n                group: 'block',\n                parseDOM: [{ tag: 'p' }],\n                toDOM() {\n                  return ['p', 0]\n                },\n              },\n              text: {\n                group: 'inline',\n              },\n            },\n          }),\n          plugins: [\n            keymap({\n              'Mod-z': undo,\n              'Mod-Z': redo,\n              'Mod-y': redo,\n              Enter: () => {\n                this.#content.updateValue?.()\n                return true\n              },\n            }),\n          ],\n        }),\n      })\n\n      this.#innerView = innerView\n      this.#content.innerView = this.#innerView\n      this.#content.updateValue = () => {\n        const { tr } = view.state\n        tr.setNodeAttribute(textFrom, 'value', innerView.state.doc.textContent)\n        view.dispatch(tr)\n        requestAnimationFrame(() => {\n          view.focus()\n        })\n      }\n      return true\n    }\n\n    const show = shouldShow()\n    if (!show) this.#onHide()\n    return show\n  }\n\n  update = (view: EditorView, prevState?: EditorState) => {\n    this.#provider.update(view, prevState)\n  }\n\n  destroy = () => {\n    this.#provider.destroy()\n    this.#content.remove()\n  }\n}\n","import { $inputRule } from '@milkdown/kit/utils'\nimport { nodeRule } from '@milkdown/kit/prose'\nimport { mathInlineSchema } from './inline-latex'\nimport { codeBlockSchema } from '@milkdown/kit/preset/commonmark'\nimport { textblockTypeInputRule } from '@milkdown/kit/prose/inputrules'\n\n/// Input rule for inline math.\n/// When you type $E=MC^2$, it will create an inline math node.\nexport const mathInlineInputRule = $inputRule((ctx) =>\n  nodeRule(/(?:\\$)([^$]+)(?:\\$)$/, mathInlineSchema.type(ctx), {\n    getAttr: (match) => {\n      return {\n        value: match[1] ?? '',\n      }\n    },\n  })\n)\n\n/// A input rule for creating block math.\n/// For example, `$$ ` will create a code block with language javascript.\nexport const mathBlockInputRule = $inputRule((ctx) =>\n  textblockTypeInputRule(/^\\$\\$[\\s\\n]$/, codeBlockSchema.type(ctx), () => ({\n    language: 'LaTeX',\n  }))\n)\n","import { codeBlockSchema } from '@milkdown/kit/preset/commonmark'\n\nexport const blockLatexSchema = codeBlockSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      toMarkdown: {\n        match: baseSchema.toMarkdown.match,\n        runner: (state, node) => {\n          const language = node.attrs.language ?? ''\n          if (language.toLowerCase() === 'latex') {\n            state.addNode(\n              'math',\n              undefined,\n              node.content.firstChild?.text || ''\n            )\n          } else {\n            return baseSchema.toMarkdown.runner(state, node)\n          }\n        },\n      },\n    }\n  }\n})\n","import type { KatexOptions } from 'katex'\nimport katex from 'katex'\nimport { codeBlockConfig } from '@milkdown/kit/component/code-block'\nimport { CrepeFeature } from '../..'\nimport { FeaturesCtx } from '../../core/slice'\nimport type { DefineFeature, Icon } from '../shared'\nimport { remarkMathBlockPlugin, remarkMathPlugin } from './remark'\nimport { mathInlineSchema } from './inline-latex'\nimport { defIfNotExists } from '../../utils'\nimport { LatexInlineEditElement } from './inline-tooltip/component'\nimport { inlineLatexTooltip } from './inline-tooltip/tooltip'\nimport { LatexInlineTooltip } from './inline-tooltip/view'\nimport { confirmIcon } from '../../icons'\nimport { mathBlockInputRule, mathInlineInputRule } from './input-rule'\nimport { blockLatexSchema } from './block-latex'\n\nexport interface LatexConfig {\n  katexOptions: KatexOptions\n  inlineEditConfirm: Icon\n}\n\nexport type LatexFeatureConfig = Partial<LatexConfig>\n\ndefIfNotExists('milkdown-latex-inline-edit', LatexInlineEditElement)\nexport const defineFeature: DefineFeature<LatexFeatureConfig> = (\n  editor,\n  config\n) => {\n  editor\n    .config((ctx) => {\n      const flags = ctx.get(FeaturesCtx)\n      const isCodeMirrorEnabled = flags.includes(CrepeFeature.CodeMirror)\n      if (!isCodeMirrorEnabled) {\n        throw new Error('You need to enable CodeMirror to use LaTeX feature')\n      }\n\n      ctx.update(codeBlockConfig.key, (prev) => ({\n        ...prev,\n        renderPreview: (language, content) => {\n          if (language.toLowerCase() === 'latex' && content.length > 0) {\n            return renderLatex(content, config?.katexOptions)\n          }\n          const renderPreview = prev.renderPreview\n          return renderPreview(language, content)\n        },\n      }))\n\n      ctx.set(inlineLatexTooltip.key, {\n        view: (view) => {\n          return new LatexInlineTooltip(ctx, view, {\n            inlineEditConfirm: config?.inlineEditConfirm ?? (() => confirmIcon),\n            ...config,\n          })\n        },\n      })\n    })\n    .use(remarkMathPlugin)\n    .use(remarkMathBlockPlugin)\n    .use(mathInlineSchema)\n    .use(inlineLatexTooltip)\n    .use(mathInlineInputRule)\n    .use(mathBlockInputRule)\n    .use(blockLatexSchema)\n}\n\nfunction renderLatex(content: string, options?: KatexOptions) {\n  const html = katex.renderToString(content, {\n    ...options,\n    throwOnError: false,\n    displayMode: true,\n  })\n  return html\n}\n"],"names":["mathFlow","tokenize","effects","ok","nok","self","this","tail","events","length","initialSize","type","sliceSerialize","sizeOpen","code","enter","sequenceOpen","consume","exit","factorySpace","metaBefore","markdownLineEnding","metaAfter","contentType","meta","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","after","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","size","sequenceClose","parser","constructs","disable","null","includes","undefined","afterSequenceClose","concrete","name","lineStart","lazy","now","line","mathText","options","single","singleDollarTextMath","token","between","data","resolve","resolveMathText","previous","index","tailExitIndex","headEnterIndex","end","splice","emptyOptions","remarkMath","settings","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","push","flow","text","math","value","hName","hChildren","tagName","properties","className","children","mathFlowFenceMeta","buffer","hProperties","resume","replace","node","stack","assert","mathFlowInside","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathFromMarkdown","inlineMath","peek","unsafe","character","inConstruct","atBreak","handlers","_","state","info","raw","tracker","createTracker","sequence","repeat","Math","max","longestStreak","move","subexit","safe","before","encode","current","RegExp","test","pattern","expression","compilePattern","match","exec","position","codePointAt","slice","mathToMarkdown","remarkMathPlugin","$remark","visitMathBlock","ast","visit","parent","newNode","lang","remarkMathBlockPlugin","latexEditComponent","_ref","innerView","updateValue","_a","html","h","dom","e","preventDefault","inlineEditConfirm","props","Object","Function","LatexInlineEditElement","c","inlineLatexTooltip","tooltipFactory","_content","_provider","_dom","_innerView","_onHide","_shouldShow","LatexInlineTooltip","constructor","ctx","view","__privateAdd","__privateGet","destroy","__privateSet","show","shouldShow","selection","schema","empty","NodeSelection","mathInlineId","textFrom","from","paragraph","nodes","create","attrs","EditorView","EditorState","doc","Schema","content","group","parseDOM","tag","toDOM","plugins","keymap","undo","redo","Enter","_b","tr","setNodeAttribute","textContent","dispatch","requestAnimationFrame","focus","update","prevState","remove","TooltipProvider","debounce","offset","floatingUIOptions","placement","document","createElement","WeakMap","mathInlineInputRule","$inputRule","nodeRule","mathInlineSchema","getAttr","mathBlockInputRule","textblockTypeInputRule","codeBlockSchema","language","blockLatexSchema","extendSchema","prev","baseSchema","toMarkdown","runner","toLowerCase","addNode","firstChild","defIfNotExists","defineFeature","editor","get","FeaturesCtx","CrepeFeature","CodeMirror","Error","codeBlockConfig","key","renderPreview","katex","throwOnError","displayMode","renderLatex","katexOptions","set","confirmIcon","use"],"sourceRoot":""}